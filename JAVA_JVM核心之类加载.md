# JVM核心

## 一、JVM运行和类加载全过程

1. **类加载全过程**

   * 为什么研究类加载全过程？

     * 有助于了解JVM运行过程
     * 更深入了解java动态性，（解热部署、动态加载），提高程序的灵活性

   * **类加载机制**

     ​		JVM把class文件加载到内存，并对数据进行校验、解析和初始化，最终形成JVM可以直接使用的Java类型的过程

     * 加载

       ​		将class文件字节码内容加载到内存中，并将这些镜头数据转换成方法区中的运行时数据结构，在堆中生成一个代表这个类的java.lang.Class对象，作为方法区类数据的访问入口。这个过程需要类加载器参与。

     * 链接

       ​		将Java类的二进制代码合并到JVM的运行状态之中的过程

       * 验证：确保加载的类信息符合JVM规范，没有安全方面的问题
       * 准备：正式为类变量（static变量）分配内存并设置类变量初始化值的阶段，这些内存都将在方法区中进行分配。
       * 解析：虚拟机常量池内的符号引用替换为直接引用的过程

     * 初始化

       * 初始化阶段是执行类构造器<clinit>()方法的过程。类构造器<clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static块）中的语句合并产生的。
       * 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先进行其父类的初始化
       * 虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确加锁和同步。

   * 类的主动引用（一定会发生类的初始化）

     * new一个类的对象
     * 调用类的静态成员（除了final常量）和静态方法
     * 使用java.lang.reflect包的方法对类进行反射调用
     * 当虚拟机启动，java Hello，则一定会初始化Hello类。即：先启动main方法所在的类
     * 当初始化一个类，如果其父类没有被初始化，则先会初始它的父类

   * 类的被动引用（不会发生类的初始化）

     * 当访问一个静态域时，只有真正声明这个域的类才会被初始化

       * 通过子类引用父类的静态变量，不会导致子类初始化

     * 通过数组定义类引用，不会触发此类的初始化

       ```java
       A[] as = new A[10];
       ```

     * 引用常量不会触发此类的初始化（常量在编译阶段就存入调用类的常量池中了）

## 二、深入类加载器

